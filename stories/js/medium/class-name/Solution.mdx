---
title: classNames() — Solution
---

## Solution Explanation

The key challenge is handling multiple argument types recursively while filtering falsey values. The solution processes each argument type differently:

- **Strings/Numbers**: Add directly to the collection
- **Arrays**: Recursively process each element
- **Objects**: Include keys with truthy values
- **Falsey values**: Ignore completely

## Recommended Solution: Pure Recursive

This approach uses direct recursion through the main function, making it clean and maintainable:

```typescript
type ClassValue = ClassArray | ClassDictionary | string | number | null | boolean | undefined;
type ClassDictionary = Record<string, any>;
type ClassArray = Array<ClassValue>;

export default function classNames(...args: Array<ClassValue>): string {
  const classes: Array<string> = [];

  const process = (arg: ClassValue) => {
    // Ignore falsey values
    if (!arg) {
      return;
    }

    const argType = typeof arg;

    // Handle strings and numbers
    if (argType === 'string' || argType === 'number') {
      classes.push(String(arg));
      return;
    }

    // Handle arrays recursively
    if (Array.isArray(arg)) {
      arg.forEach(process);
      return;
    }

    // Handle objects
    if (argType === 'object') {
      const objArg = arg as ClassDictionary;
      for (const key in objArg) {
        // Only process non-inherited keys with truthy values
        if (Object.hasOwn(objArg, key) && objArg[key]) {
          classes.push(key);
        }
      }
      return;
    }
  };

  args.forEach(process);
  return classes.join(' ');
}
```

### How It Works

1. **Create collection**: Initialize an empty array to collect class names
2. **Define processor**: Create an inner function to process each argument recursively
3. **Process each argument**: Call processor on all arguments
4. **Join results**: Combine all classes with spaces

### Step-by-Step Example

```typescript
classNames('foo', { bar: true, baz: false }, ['qux'])

// Step 1: Process 'foo'
//   → Add to classes: ['foo']

// Step 2: Process { bar: true, baz: false }
//   → bar is truthy → add: ['foo', 'bar']
//   → baz is falsey → skip

// Step 3: Process ['qux']
//   → Recursively process 'qux'
//   → Add to classes: ['foo', 'bar', 'qux']

// Result: 'foo bar qux'
```

## Alternative: Inner Helper Function

A slightly different approach using an inner helper that modifies external state:

```typescript
export default function classNames(...args: Array<ClassValue>): string {
  const classes: Array<string> = [];

  function process(...args: Array<ClassValue>) {
    args.forEach((arg) => {
      if (!arg) return;

      const argType = typeof arg;

      if (argType === 'string' || argType === 'number') {
        classes.push(String(arg));
        return;
      }

      if (Array.isArray(arg)) {
        process(...arg); // Spread array for recursion
        return;
      }

      if (argType === 'object') {
        const objArg = arg as ClassDictionary;
        for (const key in objArg) {
          if (Object.hasOwn(objArg, key) && objArg[key]) {
            classes.push(key);
          }
        }
      }
    });
  }

  process(...args);
  return classes.join(' ');
}
```

## Real-World React Example

```typescript
function Button({ variant, size, disabled, className }) {
  return (
    <button
      className={classNames(
        'btn',
        {
          'btn-primary': variant === 'primary',
          'btn-secondary': variant === 'secondary',
          'btn-large': size === 'large',
          'btn-small': size === 'small',
          'btn-disabled': disabled,
        },
        className // Allow custom classes to be passed
      )}
    >
      Click me
    </button>
  );
}

// Usage:
<Button variant="primary" size="large" disabled={false} />
// Result: 'btn btn-primary btn-large'

<Button variant="secondary" size="small" disabled />
// Result: 'btn btn-secondary btn-small btn-disabled'
```

## Handling Edge Cases

### Falsey Value Filtering

```typescript
classNames(
  null,              // Ignored
  undefined,         // Ignored
  false,             // Ignored
  '',                // Ignored
  0,                 // Ignored
  'visible',         // ✓ Added
  1,                 // ✓ Added
  'active'           // ✓ Added
);
// Result: 'visible 1 active'
```

### Nested Array Flattening

```typescript
classNames(
  'a',
  ['b', 'c'],        // Flattens
  ['d', ['e', 'f']]  // Deeply nested
);
// Result: 'a b c d e f'
```

### Object Value Evaluation

```typescript
const isActive = true;
const isDisabled = false;

classNames({
  'active': isActive,      // ✓ Added (truthy)
  'disabled': isDisabled,  // Skipped (falsey)
  'visible': 1,            // ✓ Added (truthy number)
  'hidden': null,          // Skipped (falsey)
  'focus': 'yes'           // ✓ Added (truthy string)
});
// Result: 'active visible focus'
```

## Comparison of Approaches

| Approach | Pros | Cons |
|----------|------|------|
| Pure Recursive | Clean, intuitive | Closure overhead |
| Inner Helper | Direct recursion | Slightly more code |
| Using apply() | Classic implementation | Less readable |

## Performance Considerations

- **Time Complexity**: O(n) where n is total elements across all arguments
- **Space Complexity**: O(n) for storing class names
- **Recursion Depth**: Limited by call stack (rarely an issue in practice)

## Important Implementation Notes

⚠️ **Order matters for objects:**
```typescript
classNames('foo', { foo: false })
// Result: 'foo' (not deduplicated)
// The specification doesn't require deduplication
```

✅ **Use Object.hasOwn() for safety:**
```typescript
// Ensures we only process own properties, not inherited ones
if (Object.hasOwn(objArg, key) && objArg[key]) {
  classes.push(key);
}
```

✅ **Array must be checked before object:**
```typescript
// Because typeof [] === 'object'
// So Array.isArray() must come before checking argType === 'object'
```

## Follow-Up: De-duplication

In some cases, you might want to deduplicate classes:

```typescript
export default function classNames(...args: Array<ClassValue>): string {
  const classSet = new Set<string>();

  const process = (arg: ClassValue) => {
    // ... same logic but use Set instead
    if (argType === 'string' || argType === 'number') {
      classSet.add(String(arg));
    }
    // ...
  };

  args.forEach(process);
  return Array.from(classSet).join(' ');
}
```

**Note**: De-duplication is usually out of scope for interviews but is a good follow-up question.

## Library Implementations

For reference, the official classnames library uses `arguments` and imperative loops:

```ts
export default function classNames() {
  var classes = [];

  for (var i = 0; i < arguments.length; i++) {
    var arg = arguments[i];
    if (!arg) continue;

    var argType = typeof arg;

    if (argType === 'string' || argType === 'number') {
      classes.push(arg);
    } else if (Array.isArray(arg)) {
      if (arg.length) {
        var inner = classNames.apply(null, arg);
        if (inner) {
          classes.push(inner);
        }
      }
    } else if (argType === 'object') {
      for (var key in arg) {
        if (hasOwn.call(arg, key) && arg[key]) {
          classes.push(key);
        }
      }
    }
  }

  return classes.join(' ');
}
```

## Techniques Used

- Recursion for nested array handling
- Type checking with `typeof` and `Array.isArray()`
- Object iteration with `for...in` and `Object.hasOwn()`
- Closures to maintain state across recursive calls
- Variadic arguments with spread operator

## Resources

- [classnames - GitHub](https://github.com/JedWatson/classnames)
- [clsx - GitHub](https://github.com/lukeed/clsx) - Faster alternative
- [typeof - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof)
- [Array.isArray() - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)

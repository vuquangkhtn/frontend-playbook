---
title: Array.prototype.at — Solution
---

## Solution Explanation

The `Array.prototype.at()` method allows accessing elements of an array using both positive and negative indices, similar to Python's list indexing. This is convenient when accessing items from the back of the array.

Traditionally, to access the last item you'd do `arr[arr.length - 1]`, but with this method you can simply do `arr.at(-1)`.

## How It Works

For indices that are **out of bounds** (defined as `index < -array.length || index >= array.length`), `undefined` is returned.

To handle both positive and negative indices:

1. We add `array.length` to negative indices to convert them to their positive counterpart
2. We use the modulo operator to keep indices within the array range
3. The index is converted to an integer first, so `Array.prototype.at` works even for string versions of indices

## Simple Solution

```typescript
Array.prototype.myAt = function (index) {
  const len = this.length;
  if (index < -len || index >= len) {
    return;
  }

  return this[(index + len) % len];
};
```

## Specification-Compliant Solution

Here's a solution based on the ECMAScript specification:

```typescript
Array.prototype.myAt = function (index) {
  const len = this.length;
  const relativeIndex = Number(index);
  const k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;

  if (k < 0 || k >= len) {
    return undefined;
  }

  return this[k];
};
```

### Key Differences

- Explicitly converts the index to a number
- Separately calculates the actual index (`k`)
- Returns explicit `undefined` for clarity

## Edge Cases

- ✅ Non-integer indices like `[42, 79].at('1')` are converted to numbers
- ✅ Empty arrays return `undefined`
- ✅ Sparse arrays preserve their gaps

## Resources

- [Array.prototype.at - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at)
- [Array.prototype.at - ECMAScript Specification](https://tc39.es/ecma262/#sec-array.prototype.at)
